/*
 Navicat Premium Data Transfer

 Source Server         : CIblog
 Source Server Type    : MySQL
 Source Server Version : 100410
 Source Host           : localhost:3306
 Source Schema         : ciblog

 Target Server Type    : MySQL
 Target Server Version : 100410
 File Encoding         : 65001

 Date: 11/02/2020 13:08:56
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for ciblog_article
-- ----------------------------
DROP TABLE IF EXISTS `ciblog_article`;
CREATE TABLE `ciblog_article`  (
  `aid` int(11) NOT NULL AUTO_INCREMENT COMMENT '文章编号',
  `title` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '文章标题',
  `html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '文章h5',
  `text` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '文章正文',
  `create_date` datetime(0) NULL DEFAULT NULL COMMENT '发表时间',
  `modify_date` datetime(0) NULL DEFAULT NULL COMMENT '最后编辑时间',
  `order` int(255) NULL DEFAULT NULL COMMENT '排序',
  `author_id` int(11) NULL DEFAULT NULL COMMENT '作者id',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '暂时没有使用 状态字段',
  `comment_count` int(11) UNSIGNED NULL DEFAULT 0 COMMENT '评论数',
  `allow_comment` int(11) UNSIGNED NULL DEFAULT 1 COMMENT '0-不允许\r\n1-允许',
  `pv` int(255) NULL DEFAULT 0 COMMENT '阅读量',
  `cover_url` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '封面连接',
  `description` longtext CHARACTER SET utf32 COLLATE utf32_general_ci NULL COMMENT '描述',
  PRIMARY KEY (`aid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 45 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ciblog_article
-- ----------------------------
INSERT INTO `ciblog_article` VALUES (1, '中缀表达式转后缀表达式', '<h2><a id=\"_0\"></a>什么叫做中缀表达式</h2>\n<p>中缀表达式是人们常用的算术表示方法。<br />\n例如:<code>1 + 2 * 3 - 4</code></p>\n<hr />\n<h2><a id=\"_8\"></a>什么叫做后缀表达式</h2>\n<p>后缀表达式（将运算符写在操作数之后），也可称逆波兰式（Reverse Polish notation，RPN，或逆波兰记法）。<br />\n例如:<code>1 2 3 * + 4 - （就是上面的中缀转换过来的)</code></p>\n<hr />\n<h2><a id=\"_17\"></a>为什么要使用后缀表达式</h2>\n<p><code>1 + 2 * 3 - 4</code>这种格式，大家看一下就知道如何计算，数字小的情况下甚至能很快算出结果。既然如此我们为什么要把中缀表达式转换成后缀表达式呢？</p>\n<p>这是因为中缀表达式虽然简单，但是那是对于人类的思维方式来说，中缀表示非常易于理解。可是你的计算机可不是这么想的，中缀表达式对于他来说非常复杂，无异于看天书。相反，后缀表达式在计算机中就像人类看中缀表达式一样。简单易懂。原因是计算机采用的内存结构普遍是栈式结构，先进后出。</p>\n<hr />\n<h2><a id=\"_26\"></a>中缀表达式如何转换为后缀表达式</h2>\n<p>说了这么多的理论知识，大家一定很想知道这么易于机器阅读的算数表达公式我该如何拥有呢？下面我们就一步步的了解，转换过程。</p>\n<p>1.首先我们创建一个符号栈存放符号</p>\n<p>2.拿到中缀表达式 我们分割操作数和符号 从左至右进行操作</p>\n<p>3.判断如果是操作数则直接输出</p>\n<p>4.如果是符号则出现两三种情况</p>\n<blockquote>\n<p>1.如果符号栈为空则将其入栈<br />\n2.如果符号栈不为空则于栈顶的符号进行优先级比较，<code>如果符号优先级大于栈顶符号</code>则直接入栈；<code>如果符号优先级小于等于栈顶符号</code>则将栈顶符号输出，然后将符号与新的栈顶符号继续比较，<code>直到</code>符号优先级大于栈顶符号或者栈空之后入栈。</p>\n</blockquote>\n<p>5.如果遇到<code>左括号</code>则入栈</p>\n<p>6.如果遇到<code>右括号</code>则将距离栈顶最近的<code>右括号</code>之间的所有符号依次出栈，然后丢弃<code>左括号</code></p>\n<p>7.循环3~6的操作直到结束</p>\n<p>8.这时候我们就得到了后缀表达式</p>\n<hr />\n<h2><a id=\"_53\"></a>举栗说明</h2>\n<p>说了那么多我想还是有的小伙伴比较懵，所以我们举个例子好了</p>\n<p>随便来一个公式: <code>1*2+16/4-6*2</code></p>\n<p>我们将他从字符串拆分: <code>1 * 2 + 16 / 4 - 6 * 2</code></p>\n<p>接着按照上面的步骤依次操作</p>\n<blockquote>\n<p>1.<code>1</code>直接输出<br />\n|  输出: &quot;1 &quot;                      |  符号栈: []        |<br />\n2.<code>*</code>因为符号栈空所以入栈<br />\n|  输出: &quot;1 &quot;                      |  符号栈:[’<em>’]      |<br />\n3.<code>2</code>直接输出<br />\n|  输出: &quot;1 2 &quot;                    |  符号栈:[’</em>’]      |<br />\n4.<code>+</code>与符号栈顶进行比较:<code>+</code>优先级小于<code>*</code>所以输出<code>*</code>;因为符号栈空所以<code>+</code>入栈<br />\n|  输出: &quot;1 2 * &quot;                  |  符号栈:[’+’]      |<br />\n5.<code>16</code>直接输出<br />\n|  输出: &quot;1 2 * 16 &quot;               |  符号栈:[’+’]      |<br />\n6.<code>/</code>与符号栈顶进行比较:<code>/</code>优先级大于<code>+</code>所以<code>/</code>入栈<br />\n|  输出: &quot;1 2 * 16 &quot;               |  符号栈:[’+’,’/’]  |<br />\n7.<code>4</code>直接输出<br />\n|  输出: &quot;1 2 * 16 4 &quot;             |  符号栈:[’+’,’/’]  |<br />\n8.<code>-</code>与符号栈顶进行比较:<code>-</code>优先级小于<code>/</code>所以输出<code>/</code>;<code>-</code>优先级等于<code>+</code>所以输出<code>+</code>;因为符号栈空所以<code>-</code>入栈<br />\n|  输出: &quot;1 2 * 16 4 / + &quot;         |  符号栈:[’-’]      |<br />\n9.<code>6</code>直接输出<br />\n|  输出: &quot;1 2 * 16 4 / + 6 &quot;       |  符号栈:[’-’]      |<br />\n10.<code>*</code>与符号栈顶进行比较:<code>*</code>优先级大于<code>-</code>所以<code>*</code>入栈<br />\n|  输出: &quot;1 2 * 16 4 / + 6 &quot;       |  符号栈:[’-’,’<em>’]  |<br />\n11.<code>2</code>直接输出<br />\n|  输出: &quot;1 2 * 16 4 / + 6 2 &quot;     |  符号栈:[’-’,’</em>’]  |<br />\n12.表达式结束依次输出符号栈中符号<br />\n|  输出: &quot;1 2 * 16 4 / + 6 2 * - &quot; |  符号栈: []        |</p>\n</blockquote>\n<p>结束了，我们现在已经得到后缀表达式了，整个过程其实并不是很复杂，第一接触可能会觉得有些绕，自己多转换几次，很快就可以掌握了。</p>\n<hr />\n<h2><a id=\"_94\"></a>计算后缀表达式</h2>\n<p>上一步我们通过转换得到了后缀表达式：<code>1 2 * 16 4 / + 6 2 * -</code></p>\n<p>也就是说我们得到了，易于计算机理解的数学公式，那么我们这时候就应该关心，计算机是如何处理这个公式的。其实很简单。</p>\n<blockquote>\n<p>我们将上面的后缀表达式按照空格分割成为数组，循环依然是从左到右的顺序。如果当前为操作数，则压栈；如果是符号，则将两个栈顶的两个元素弹出做响应的运算，然后入栈；最后当表达式循环结束，栈中剩下的就是运算结果。<strong>这里要注意如果是除法和减法后弹出的操作数作为被减数与被除数</strong></p>\n</blockquote>\n<hr />\n<h2><a id=\"_105\"></a>依然举栗说明</h2>\n<p>后缀表达式：<code>1 2 * 16 4 / + 6 2 * -</code></p>\n<blockquote>\n<p>1.<code>1</code> <code>2</code> 直接入栈<br />\n| 栈 : [ 1, 2 ]     | 后缀表达式 : [ ‘<em>’, 16, 4, ‘/’, ‘+’, 6, 2, \'</em>’, ‘-’, ]<br />\n2.遇到符号<code>*</code> 计算 ： <code>1 * 2 = 3</code> 结果入栈<br />\n| 栈 : [ 2 ]        | 后缀表达式 : [ 16, 4, ‘/’, ‘+’, 6, 2, ‘<em>’, ‘-’, ]<br />\n3.<code>16</code> <code>4</code> 直接入栈<br />\n| 栈 : [ 2, 16, 4 ] | 后缀表达式 : [ ‘/’, ‘+’, 6, 2, \'</em>’, ‘-’, ]<br />\n4.遇到符号<code>/</code> 计算 ： <code>16 / 4 = 4</code> 结果入栈<br />\n| 栈 : [ 2, 4 ]     | 后缀表达式 : [ ‘+’, 6, 2, ‘<em>’, ‘-’, ]<br />\n5.遇到符号<code>+</code> 计算 ： <code>3 + 4 = 7</code> 结果入栈<br />\n| 栈 : [ 6 ]        | 后缀表达式 : [ 6, 2, \'</em>’, ‘-’, ]<br />\n6.<code>6</code> <code>2</code> 直接入栈<br />\n| 栈 : [ 6, 6, 2 ]  | 后缀表达式 : [ ‘*’, ‘-’, ]<br />\n7.遇到符号<code>*</code> 计算 ： <code>6 * 2 = 12</code> 结果入栈<br />\n| 栈 : [ 6, 12 ]    | 后缀表达式 : [  ‘-’, ]<br />\n8.遇到符号<code>-</code> 计算 ： <code>6 - 12 = -6</code> 结果入栈<br />\n| 栈 : [ -6 ]       | 后缀表达式 : []</p>\n</blockquote>\n<p>计算结束，结果为 <code>-6</code> 怎么样，是不是没有想象中的那么难。</p>\n<hr />\n<h2><a id=\"_131\"></a>代码部分</h2>\n<p><strong>使用js实现我们的逻辑</strong><br />\n我这边将从头到尾的步骤，拆分为4个函数</p>\n<ol>\n<li>stringToArray   ： 字符串转换中缀表达式</li>\n<li>infixToSuffix   ： 中缀表达式转换后缀表达式</li>\n<li>suffixResult    ： 根据后缀表达式计算结果</li>\n<li>operatorCompare ： 运算符号优先级比较</li>\n</ol>\n<p>具体实现我就不一步一步讲解了，思路就是根据，我上面讲到的转换方法。</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">     <span class=\"hljs-comment\">/**\n     *  将公式字符串转换为数组 将公式中的数组转换为Number \n     *\n     * @param {string} str - 公式字符串\n     * @returns {Array} - 中缀表达式数组 \n     */</span>\n    <span class=\"hljs-keyword\">var</span> start = <span class=\"hljs-literal\">null</span>;<span class=\"hljs-comment\">//起始时间</span>\n    <span class=\"hljs-keyword\">var</span> end = <span class=\"hljs-literal\">null</span>;  <span class=\"hljs-comment\">//结束时间</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">stringToArray</span>(<span class=\"hljs-params\">str</span>) </span>{\n        <span class=\"hljs-comment\">//console.log(\"|\",str,\"| sÎtringToArray\");</span>\n        start = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime();\n        <span class=\"hljs-keyword\">if</span> (str !== <span class=\"hljs-string\">\"\"</span> &amp;&amp; str !== <span class=\"hljs-literal\">undefined</span>) {\n            <span class=\"hljs-keyword\">let</span> data = str.split(<span class=\"hljs-string\">\'\'</span>);\n            <span class=\"hljs-keyword\">var</span> flag = <span class=\"hljs-string\">\"\"</span>;\n            <span class=\"hljs-keyword\">let</span> arr = [];\n            data.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">tmp, index</span>) =&gt;</span> {\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isNaN</span>(tmp) &amp;&amp; tmp !== <span class=\"hljs-string\">\'.\'</span>) {\n                    <span class=\"hljs-comment\">//如果是符号</span>\n                    <span class=\"hljs-keyword\">if</span> (flag !== <span class=\"hljs-string\">\"\"</span>) {\n                        arr.push(<span class=\"hljs-built_in\">parseFloat</span>(flag));\n                        arr.push(tmp);\n                        flag = <span class=\"hljs-string\">\"\"</span>;\n                    } <span class=\"hljs-keyword\">else</span> {\n                        arr.push(tmp);\n                    }\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">//如果是数字</span>\n                    flag = flag + tmp;\n                    <span class=\"hljs-keyword\">if</span> (index &gt;= data.length - <span class=\"hljs-number\">1</span>) {\n                        arr.push(<span class=\"hljs-built_in\">parseFloat</span>(flag));\n                    }\n                }\n            })\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"中缀表达式字符串:\"</span>, arr.join(<span class=\"hljs-string\">\" \"</span>));\n            <span class=\"hljs-keyword\">return</span> arr;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> [];\n        }\n    }\n\n</code></div></pre>\n<hr />\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    <span class=\"hljs-comment\">/**\n     * 将stringToArray方法中生成的数组 转换为后缀表达式\n     *\n     * @param {Array} arr - 中缀表达式数组\n     * @returns {String} - 后缀表达式字符串\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">infixToSuffix</span>(<span class=\"hljs-params\">arr</span>) </span>{\n        <span class=\"hljs-comment\">//console.log(\"|\",arr,\"| infixToSuffix\");</span>\n        <span class=\"hljs-keyword\">if</span> (arr.length &gt; <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">\"\"</span>\n            <span class=\"hljs-keyword\">let</span> operator = []\n            arr.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> {\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isNaN</span>(val)) {\n                    <span class=\"hljs-comment\">//如果是符号</span>\n                    <span class=\"hljs-keyword\">if</span> (operator.length === <span class=\"hljs-number\">0</span> || val === <span class=\"hljs-string\">\"(\"</span>) {\n                        operator.push(val)\n                    } <span class=\"hljs-keyword\">else</span> {\n                        <span class=\"hljs-keyword\">if</span> (val === <span class=\"hljs-string\">\")\"</span>) {\n                            <span class=\"hljs-keyword\">let</span> operatorLength = operator.length;\n                            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &lt; operatorLength; index++) {\n                                <span class=\"hljs-keyword\">let</span> flag = operator.pop();\n                                <span class=\"hljs-keyword\">if</span> (flag === <span class=\"hljs-string\">\"(\"</span>) {\n                                    <span class=\"hljs-keyword\">break</span>;\n                                } <span class=\"hljs-keyword\">else</span> {\n                                    str = str + flag + <span class=\"hljs-string\">\" \"</span>;\n                                }\n                            }\n                        } <span class=\"hljs-keyword\">else</span> {\n                            <span class=\"hljs-keyword\">let</span> operatorLength = operator.length;\n                            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &lt;= operatorLength + <span class=\"hljs-number\">1</span>; index++) {\n                                <span class=\"hljs-keyword\">let</span> tmp = operator.pop()\n                                <span class=\"hljs-keyword\">if</span> (tmp === <span class=\"hljs-literal\">undefined</span>) {\n                                    operator.push(val)\n                                    <span class=\"hljs-keyword\">break</span>;\n                                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (tmp === <span class=\"hljs-string\">\"(\"</span>) {\n                                    operator.push(tmp)\n                                    operator.push(val)\n                                    <span class=\"hljs-keyword\">break</span>;\n                                } <span class=\"hljs-keyword\">else</span> {\n                                    <span class=\"hljs-keyword\">let</span> flag = operatorCompare(val, tmp)\n                                    <span class=\"hljs-keyword\">if</span> (flag) {\n                                        str = str + tmp + <span class=\"hljs-string\">\" \"</span>;\n                                    } <span class=\"hljs-keyword\">else</span> {\n                                        operator.push(tmp)\n                                        operator.push(val)\n                                        <span class=\"hljs-keyword\">break</span>;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-comment\">//如果是数字</span>\n                    str = str + val + <span class=\"hljs-string\">\" \"</span>;\n                }\n            })\n    \n            <span class=\"hljs-keyword\">while</span> (operator.length !== <span class=\"hljs-number\">0</span>) {\n                str = str + operator.pop() + <span class=\"hljs-string\">\" \"</span>;\n            }\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"后缀表达式字符串:\"</span>, str);\n            <span class=\"hljs-keyword\">return</span> str;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"\"</span>\n        }\n    }\n</code></div></pre>\n<hr />\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    <span class=\"hljs-comment\">/**\n     * 计算后缀表达式\n     *\n     * @param {String} str - 后缀表达式字符串\n     * @returns {Float} - 结果数据\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">suffixResult</span>(<span class=\"hljs-params\">str</span>) </span>{\n        <span class=\"hljs-comment\">//console.log(\"|\",str,\"| suffixResult\");</span>\n        <span class=\"hljs-keyword\">if</span> (str !== <span class=\"hljs-string\">\"\"</span>) {\n            <span class=\"hljs-keyword\">let</span> data = str.split(<span class=\"hljs-string\">\' \'</span>);\n            <span class=\"hljs-keyword\">let</span> stack = []\n            data.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> {\n                <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">isNaN</span>(<span class=\"hljs-built_in\">parseFloat</span>(data))) {\n                    stack.push(<span class=\"hljs-built_in\">parseFloat</span>(data))\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-keyword\">switch</span> (data) {\n                        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"+\"</span>:\n                            stack.push(<span class=\"hljs-built_in\">parseFloat</span>(stack.pop()) + <span class=\"hljs-built_in\">parseFloat</span>(stack.pop()))\n                            <span class=\"hljs-keyword\">break</span>;\n                        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"-\"</span>:\n                            <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-built_in\">parseFloat</span>(stack.pop()); <span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-built_in\">parseFloat</span>(stack.pop())\n                            stack.push(b - a);\n                            <span class=\"hljs-keyword\">break</span>;\n                        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"*\"</span>:\n                            stack.push(<span class=\"hljs-built_in\">parseFloat</span>(stack.pop()) * <span class=\"hljs-built_in\">parseFloat</span>(stack.pop()))\n                            <span class=\"hljs-keyword\">break</span>;\n                        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"/\"</span>:\n                            <span class=\"hljs-keyword\">let</span> aa = <span class=\"hljs-built_in\">parseFloat</span>(stack.pop()); <span class=\"hljs-keyword\">let</span> bb = <span class=\"hljs-built_in\">parseFloat</span>(stack.pop())\n                            stack.push(bb / aa);\n                            <span class=\"hljs-keyword\">break</span>;\n                        <span class=\"hljs-keyword\">default</span>:\n                            <span class=\"hljs-keyword\">break</span>;\n                    }\n                }\n            })\n            <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-built_in\">parseFloat</span>(stack.pop())\n            end = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime();\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"运算时间: \"</span> + (end - start) + <span class=\"hljs-string\">\"ms\"</span>);\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"运算结果:\"</span>, result);\n            <span class=\"hljs-keyword\">return</span> result.toString()\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"\"</span>\n        }\n    }\n</code></div></pre>\n<hr />\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">    <span class=\"hljs-comment\">/**\n     * 比较传入的两个符号的优先级\n     *\n     * @param {String} a\n     * @param {String} b\n     * @returns {Boolean} - 返回true a&lt;=b  返回false a&gt;b\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">operatorCompare</span>(<span class=\"hljs-params\">a, b</span>) </span>{\n        <span class=\"hljs-keyword\">let</span> test1 = (a === <span class=\"hljs-string\">\"+\"</span> || a === <span class=\"hljs-string\">\"-\"</span>) ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">let</span> test2 = (b === <span class=\"hljs-string\">\"+\"</span> || b === <span class=\"hljs-string\">\"-\"</span>) ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">return</span> test1 &lt;= test2\n    }\n\n</code></div></pre>\n<h2><a id=\"_323\"></a>我想说的话</h2>\n<p>本人接触计算机行业也就2年的时间，能力有限，有一些更加优雅，更加简洁的写法我还需要慢慢学习，慢慢探索。如果有大佬看到这篇文章，发现内容上有错误，或者觉得我的代码有什么不足之处可以改进。希望您能留言，不胜感激。</p>\n<p><strong>注:本文部分术语资料查询自「<a href=\"https://baike.baidu.com/item/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/6160580?fr=aladdin\" target=\"_blank\">百度百科</a>」</strong></p>\n', '什么叫做中缀表达式\n-------------\n\n中缀表达式是人们常用的算术表示方法。\n例如:`1 + 2 * 3 - 4`\n\n----------\n\n什么叫做后缀表达式\n-------------\n\n\n后缀表达式（将运算符写在操作数之后），也可称逆波兰式（Reverse Polish notation，RPN，或逆波兰记法）。\n例如:`1 2 3 * + 4 -  （就是上面的中缀转换过来的)`\n\n----------\n\n为什么要使用后缀表达式\n-------------\n\n`1 + 2 * 3 - 4`这种格式，大家看一下就知道如何计算，数字小的情况下甚至能很快算出结果。既然如此我们为什么要把中缀表达式转换成后缀表达式呢？\n\n这是因为中缀表达式虽然简单，但是那是对于人类的思维方式来说，中缀表示非常易于理解。可是你的计算机可不是这么想的，中缀表达式对于他来说非常复杂，无异于看天书。相反，后缀表达式在计算机中就像人类看中缀表达式一样。简单易懂。原因是计算机采用的内存结构普遍是栈式结构，先进后出。\n\n----------\n\n中缀表达式如何转换为后缀表达式\n-------------\n\n说了这么多的理论知识，大家一定很想知道这么易于机器阅读的算数表达公式我该如何拥有呢？下面我们就一步步的了解，转换过程。\n\n\n1.首先我们创建一个符号栈存放符号\n\n2.拿到中缀表达式 我们分割操作数和符号 从左至右进行操作\n\n3.判断如果是操作数则直接输出\n\n4.如果是符号则出现两三种情况\n\n>1.如果符号栈为空则将其入栈\n>2.如果符号栈不为空则于栈顶的符号进行优先级比较，`如果符号优先级大于栈顶符号`则直接入栈；`如果符号优先级小于等于栈顶符号`则将栈顶符号输出，然后将符号与新的栈顶符号继续比较，`直到`符号优先级大于栈顶符号或者栈空之后入栈。\n\n5.如果遇到`左括号`则入栈\n\n6.如果遇到`右括号`则将距离栈顶最近的`右括号`之间的所有符号依次出栈，然后丢弃`左括号`\n\n7.循环3~6的操作直到结束\n\n8.这时候我们就得到了后缀表达式\n\n----------\n\n举栗说明\n-------------\n\n说了那么多我想还是有的小伙伴比较懵，所以我们举个例子好了\n\n随便来一个公式: `1*2+16/4-6*2`\n\n我们将他从字符串拆分: `1 * 2 + 16 / 4 - 6 * 2`\n\n接着按照上面的步骤依次操作\n\n>1.`1`直接输出  \n>        |  输出: \"1 \"                      |  符号栈: []        |\n>2.`*`因为符号栈空所以入栈\n>        |  输出: \"1 \"                      |  符号栈:[\'*\']      |\n>3.`2`直接输出  \n>        |  输出: \"1 2 \"                    |  符号栈:[\'*\']      |\n>4.`+`与符号栈顶进行比较:`+`优先级小于`*`所以输出`*`;因为符号栈空所以`+`入栈\n>        |  输出: \"1 2 * \"                  |  符号栈:[\'+\']      |\n>5.`16`直接输出  \n>        |  输出: \"1 2 * 16 \"               |  符号栈:[\'+\']      |\n>6.`/`与符号栈顶进行比较:`/`优先级大于`+`所以`/`入栈\n>        |  输出: \"1 2 * 16 \"               |  符号栈:[\'+\',\'/\']  |\n>7.`4`直接输出  \n>        |  输出: \"1 2 * 16 4 \"             |  符号栈:[\'+\',\'/\']  |\n>8.`-`与符号栈顶进行比较:`-`优先级小于`/`所以输出`/`;`-`优先级等于`+`所以输出`+`;因为符号栈空所以`-`入栈\n>        |  输出: \"1 2 * 16 4 / + \"         |  符号栈:[\'-\']      |\n>9.`6`直接输出  \n>        |  输出: \"1 2 * 16 4 / + 6 \"       |  符号栈:[\'-\']      |\n>10.`*`与符号栈顶进行比较:`*`优先级大于`-`所以`*`入栈\n>        |  输出: \"1 2 * 16 4 / + 6 \"       |  符号栈:[\'-\',\'*\']  |\n>11.`2`直接输出  \n>        |  输出: \"1 2 * 16 4 / + 6 2 \"     |  符号栈:[\'-\',\'*\']  |\n>12.表达式结束依次输出符号栈中符号  \n>        |  输出: \"1 2 * 16 4 / + 6 2 * - \" |  符号栈: []        |\n\n结束了，我们现在已经得到后缀表达式了，整个过程其实并不是很复杂，第一接触可能会觉得有些绕，自己多转换几次，很快就可以掌握了。\n\n\n\n----------\n计算后缀表达式\n-------------\n\n上一步我们通过转换得到了后缀表达式：`1 2 * 16 4 / + 6 2 * - ` \n\n也就是说我们得到了，易于计算机理解的数学公式，那么我们这时候就应该关心，计算机是如何处理这个公式的。其实很简单。\n\n>我们将上面的后缀表达式按照空格分割成为数组，循环依然是从左到右的顺序。如果当前为操作数，则压栈；如果是符号，则将两个栈顶的两个元素弹出做响应的运算，然后入栈；最后当表达式循环结束，栈中剩下的就是运算结果。**这里要注意如果是除法和减法后弹出的操作数作为被减数与被除数**\n\n----------\n\n依然举栗说明\n---------\n\n后缀表达式：`1 2 * 16 4 / + 6 2 * - `\n\n>1.`1` `2` 直接入栈\n>        | 栈 : [ 1, 2 ]     | 后缀表达式 : [ \'*\', 16, 4, \'/\', \'+\', 6, 2, \'*\', \'-\', ]  \n>2.遇到符号`*` 计算 ： `1 * 2 = 3` 结果入栈\n>        | 栈 : [ 2 ]        | 后缀表达式 : [ 16, 4, \'/\', \'+\', 6, 2, \'*\', \'-\', ]  \n>3.`16` `4` 直接入栈\n>        | 栈 : [ 2, 16, 4 ] | 后缀表达式 : [ \'/\', \'+\', 6, 2, \'*\', \'-\', ]  \n>4.遇到符号`/` 计算 ： `16 / 4 = 4` 结果入栈\n>        | 栈 : [ 2, 4 ]     | 后缀表达式 : [ \'+\', 6, 2, \'*\', \'-\', ]  \n>5.遇到符号`+` 计算 ： `3 + 4 = 7` 结果入栈\n>        | 栈 : [ 6 ]        | 后缀表达式 : [ 6, 2, \'*\', \'-\', ]  \n>6.`6` `2` 直接入栈\n>        | 栈 : [ 6, 6, 2 ]  | 后缀表达式 : [ \'*\', \'-\', ]  \n>7.遇到符号`*` 计算 ： `6 * 2 = 12` 结果入栈\n>        | 栈 : [ 6, 12 ]    | 后缀表达式 : [  \'-\', ]  \n>8.遇到符号`-` 计算 ： `6 - 12 = -6` 结果入栈\n>        | 栈 : [ -6 ]       | 后缀表达式 : []  \n\n计算结束，结果为 `-6` 怎么样，是不是没有想象中的那么难。\n\n----------\n\n代码部分\n---------\n\n**使用js实现我们的逻辑**\n我这边将从头到尾的步骤，拆分为4个函数\n\n1. stringToArray   ： 字符串转换中缀表达式\n2. infixToSuffix   ： 中缀表达式转换后缀表达式\n3. suffixResult    ： 根据后缀表达式计算结果\n4. operatorCompare ： 运算符号优先级比较\n\n具体实现我就不一步一步讲解了，思路就是根据，我上面讲到的转换方法。\n```javascript\n     /**\n     *  将公式字符串转换为数组 将公式中的数组转换为Number \n     *\n     * @param {string} str - 公式字符串\n     * @returns {Array} - 中缀表达式数组 \n     */\n    var start = null;//起始时间\n    var end = null;  //结束时间\n    function stringToArray(str) {\n        //console.log(\"|\",str,\"| sÎtringToArray\");\n        start = new Date().getTime();\n        if (str !== \"\" && str !== undefined) {\n            let data = str.split(\'\');\n            var flag = \"\";\n            let arr = [];\n            data.forEach((tmp, index) => {\n                if (isNaN(tmp) && tmp !== \'.\') {\n                    //如果是符号\n                    if (flag !== \"\") {\n                        arr.push(parseFloat(flag));\n                        arr.push(tmp);\n                        flag = \"\";\n                    } else {\n                        arr.push(tmp);\n                    }\n                } else {\n                    //如果是数字\n                    flag = flag + tmp;\n                    if (index >= data.length - 1) {\n                        arr.push(parseFloat(flag));\n                    }\n                }\n            })\n            console.log(\"中缀表达式字符串:\", arr.join(\" \"));\n            return arr;\n        } else {\n            return [];\n        }\n    }\n\n```\n\n----------\n\n```javascript\n    /**\n     * 将stringToArray方法中生成的数组 转换为后缀表达式\n     *\n     * @param {Array} arr - 中缀表达式数组\n     * @returns {String} - 后缀表达式字符串\n     */\n    function infixToSuffix(arr) {\n        //console.log(\"|\",arr,\"| infixToSuffix\");\n        if (arr.length > 0) {\n            let str = \"\"\n            let operator = []\n            arr.forEach((val) => {\n                if (isNaN(val)) {\n                    //如果是符号\n                    if (operator.length === 0 || val === \"(\") {\n                        operator.push(val)\n                    } else {\n                        if (val === \")\") {\n                            let operatorLength = operator.length;\n                            for (let index = 0; index < operatorLength; index++) {\n                                let flag = operator.pop();\n                                if (flag === \"(\") {\n                                    break;\n                                } else {\n                                    str = str + flag + \" \";\n                                }\n                            }\n                        } else {\n                            let operatorLength = operator.length;\n                            for (let index = 0; index <= operatorLength + 1; index++) {\n                                let tmp = operator.pop()\n                                if (tmp === undefined) {\n                                    operator.push(val)\n                                    break;\n                                } else if (tmp === \"(\") {\n                                    operator.push(tmp)\n                                    operator.push(val)\n                                    break;\n                                } else {\n                                    let flag = operatorCompare(val, tmp)\n                                    if (flag) {\n                                        str = str + tmp + \" \";\n                                    } else {\n                                        operator.push(tmp)\n                                        operator.push(val)\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    //如果是数字\n                    str = str + val + \" \";\n                }\n            })\n    \n            while (operator.length !== 0) {\n                str = str + operator.pop() + \" \";\n            }\n            console.log(\"后缀表达式字符串:\", str);\n            return str;\n        } else {\n            return \"\"\n        }\n    }\n```\n\n----------\n```javascript\n    /**\n     * 计算后缀表达式\n     *\n     * @param {String} str - 后缀表达式字符串\n     * @returns {Float} - 结果数据\n     */\n    function suffixResult(str) {\n        //console.log(\"|\",str,\"| suffixResult\");\n        if (str !== \"\") {\n            let data = str.split(\' \');\n            let stack = []\n            data.forEach((data) => {\n                if (!isNaN(parseFloat(data))) {\n                    stack.push(parseFloat(data))\n                } else {\n                    switch (data) {\n                        case \"+\":\n                            stack.push(parseFloat(stack.pop()) + parseFloat(stack.pop()))\n                            break;\n                        case \"-\":\n                            let a = parseFloat(stack.pop()); let b = parseFloat(stack.pop())\n                            stack.push(b - a);\n                            break;\n                        case \"*\":\n                            stack.push(parseFloat(stack.pop()) * parseFloat(stack.pop()))\n                            break;\n                        case \"/\":\n                            let aa = parseFloat(stack.pop()); let bb = parseFloat(stack.pop())\n                            stack.push(bb / aa);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            })\n            let result = parseFloat(stack.pop())\n            end = new Date().getTime();\n            console.log(\"运算时间: \" + (end - start) + \"ms\");\n            console.log(\"运算结果:\", result);\n            return result.toString()\n        } else {\n            return \"\"\n        }\n    }\n```\n\n----------\n\n```javascript\n    /**\n     * 比较传入的两个符号的优先级\n     *\n     * @param {String} a\n     * @param {String} b\n     * @returns {Boolean} - 返回true a<=b  返回false a>b\n     */\n    function operatorCompare(a, b) {\n        let test1 = (a === \"+\" || a === \"-\") ? 1 : 2\n        let test2 = (b === \"+\" || b === \"-\") ? 1 : 2\n        return test1 <= test2\n    }\n\n```\n\n我想说的话\n---------\n\n本人接触计算机行业也就2年的时间，能力有限，有一些更加优雅，更加简洁的写法我还需要慢慢学习，慢慢探索。如果有大佬看到这篇文章，发现内容上有错误，或者觉得我的代码有什么不足之处可以改进。希望您能留言，不胜感激。\n\n\n**注:本文部分术语资料查询自「[百度百科][1]」**\n\n\n  [1]: https://baike.baidu.com/item/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/6160580?fr=aladdin', '2020-01-31 22:46:09', '2020-02-10 17:20:07', NULL, 1, NULL, 1, 1, 361, 'http://www.zhangyifei.top/usr/uploads/2019/07/1152248146.png', '什么叫做中缀表达式\n\n\n中缀表达式是人们常用的算术表示方法。\n例如1  2  3  4\n\n\n\n什么叫做后缀表达式\n\n\n\n后缀表达式（将运算符写在操作数之后），也可称逆波兰式（Reverse Polis');
INSERT INTO `ciblog_article` VALUES (33, '测试文章2', '<p><strong>dfasdf</strong></p>\n<h2><a id=\"dfdfdfd_1\"></a>dfdfdfd</h2>\n<p><ins>dgfhf</ins><br />\n<mark>ASDASDA</mark><br />\n<em>DGFASDF</em></p>\n<div class=\"hljs-left\">\n<p>SDFGSDFG</p>\n</div>\n<div class=\"hljs-center\">\n<p>SGDFSGDF</p>\n</div>\n<div class=\"hljs-right\">\n<p>DFGSDFG</p>\n</div>\n<blockquote>\n<p>DFSFSDF```</p>\n</blockquote>\n<pre><code class=\"lang-\">```FGHFGHFGGH\nGHFGHFGHFG\n</code></pre>\n<p>aaa</p>\n', '**dfasdf**\n## dfdfdfd\n++dgfhf++\n==ASDASDA==\n*DGFASDF*\n::: hljs-left\n\nSDFGSDFG\n\n:::\n::: hljs-center\n\nSGDFSGDF\n\n:::\n::: hljs-right\n\nDFGSDFG\n\n:::\n> DFSFSDF```\n\n```\n```FGHFGHFGGH\nGHFGHFGHFG\n```\naaa\n', '2020-02-01 18:55:52', '2020-02-10 14:04:26', NULL, 1, NULL, 0, 1, 21, 'http://www.zhangyifei.top/usr/uploads/2019/07/1152248146.png', 'dfasdf\n dfdfdfd\ndgfhf\nASDASDA\nDGFASDF\n hljsleft\n\nSDFGSDFG\n\n\n hljscenter\n\nSGDFSGDF\n\n\n hljsright\n\nDFGS');
INSERT INTO `ciblog_article` VALUES (38, '测试文章3', '<p><strong>dasdasd</strong></p>\n<h1><a id=\"sdsdsdsd_1\"></a>sdsdsdsd</h1>\n<h3><a id=\"sdsdsdsd_2\"></a>sdsdsdsd</h3>\n<h4><a id=\"sdsdsds_3\"></a>sdsdsds</h4>\n<h2><a id=\"sdsdsds_4\"></a>sdsdsds</h2>\n<h6><a id=\"sdsdsdsd_5\"></a>sdsdsdsd</h6>\n<p><ins>sdasdas</ins><br />\n<s>sdsdsd</s><br />\n<mark>sdsdsdsd</mark><br />\n<sup>sdsdsdsdsd</sup></p>\n<p><sub>sdsdsdsdsds</sub></p>\n<div class=\"hljs-left\">\n<p>dddddddddd</p>\n</div>\n<div class=\"hljs-center\">\n<p>sdsdsdsdsd</p>\n</div>\n<div class=\"hljs-right\">\n<p>sdasdasdasd</p>\n</div>\n<blockquote>\n<p>asdasdasdasdsadasdssd</p>\n</blockquote>\n<ol>\n<li>sdsadasdasdasd</li>\n<li>asdasd</li>\n<li>asd</li>\n<li>asd</li>\n<li>\n<ul>\n<li>sdasd</li>\n</ul>\n</li>\n<li>sdasd</li>\n</ol>\n', '**dasdasd**\n# sdsdsdsd\n### sdsdsdsd\n#### sdsdsds\n## sdsdsds\n###### sdsdsdsd\n++sdasdas++\n~~sdsdsd~~\n==sdsdsdsd==\n^sdsdsdsdsd^\n\n~sdsdsdsdsds~\n::: hljs-left\n\ndddddddddd\n\n:::\n\n::: hljs-center\n\nsdsdsdsdsd\n\n:::\n\n::: hljs-right\n\nsdasdasdasd\n\n:::\n\n> asdasdasdasdsadasdssd\n\n1. sdsadasdasdasd\n2. asdasd\n3. asd\n4. asd\n5. - sdasd\n6. sdasd\n\n', '2020-02-08 17:29:41', '2020-02-10 14:33:31', NULL, 1, NULL, 0, 0, 79, '', 'dasdasd\n sdsdsdsd\n sdsdsdsd\n sdsdsds\n sdsdsds\n sdsdsdsd\nsdasdas\nsdsdsd\nsdsdsdsd\n^sdsdsdsdsd^\n\nsdsdsd');
INSERT INTO `ciblog_article` VALUES (44, 'aaaaa', '<p>asdsadasd<ins>asdsaddasdasdasdasdas<em>asdasdasdasdas</em>asdasdasdasdasdas*asdas<strong>sadasdasdasds</strong>***</ins></p>\n', 'asdsadasd++asdsaddasdasdasdasdas*asdasdasdasdas*asdasdasdasdasdas*asdas**sadasdasdasds*****++', '2020-02-10 13:38:56', '2020-02-10 14:33:35', NULL, 1, NULL, 0, 1, 4, 'sdsad', 'asdsadasdasdsaddasdasdasdasdasasdasdasdasdasasdasdasdasdasdasasdassadasdasdasds');

-- ----------------------------
-- Table structure for ciblog_article_meta
-- ----------------------------
DROP TABLE IF EXISTS `ciblog_article_meta`;
CREATE TABLE `ciblog_article_meta`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `mid` int(11) NULL DEFAULT NULL COMMENT '标签或分类主键',
  `aid` int(11) NULL DEFAULT NULL COMMENT '文章主键',
  `type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '类型',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article`(`aid`) USING BTREE,
  INDEX `meta`(`mid`) USING BTREE,
  CONSTRAINT `article` FOREIGN KEY (`aid`) REFERENCES `ciblog_article` (`aid`) ON DELETE CASCADE ON UPDATE RESTRICT,
  CONSTRAINT `meta` FOREIGN KEY (`mid`) REFERENCES `ciblog_meta` (`mid`) ON DELETE SET NULL ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 281 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ciblog_article_meta
-- ----------------------------
INSERT INTO `ciblog_article_meta` VALUES (215, 87, 33, 'category');
INSERT INTO `ciblog_article_meta` VALUES (216, 88, 33, 'category');
INSERT INTO `ciblog_article_meta` VALUES (217, 72, 33, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (218, 71, 33, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (219, 89, 33, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (220, 87, 38, 'category');
INSERT INTO `ciblog_article_meta` VALUES (221, 88, 38, 'category');
INSERT INTO `ciblog_article_meta` VALUES (222, 91, 38, 'category');
INSERT INTO `ciblog_article_meta` VALUES (223, 71, 38, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (224, 72, 38, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (225, 89, 38, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (226, 90, 38, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (227, 87, 44, 'category');
INSERT INTO `ciblog_article_meta` VALUES (228, 88, 44, 'category');
INSERT INTO `ciblog_article_meta` VALUES (229, 91, 44, 'category');
INSERT INTO `ciblog_article_meta` VALUES (230, 71, 44, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (231, 72, 44, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (232, 89, 44, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (233, 90, 44, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (276, 88, 1, 'category');
INSERT INTO `ciblog_article_meta` VALUES (277, 71, 1, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (278, 72, 1, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (279, 89, 1, 'tag');
INSERT INTO `ciblog_article_meta` VALUES (280, 90, 1, 'tag');

-- ----------------------------
-- Table structure for ciblog_comment
-- ----------------------------
DROP TABLE IF EXISTS `ciblog_comment`;
CREATE TABLE `ciblog_comment`  (
  `cid` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'ip地址',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '评论内容',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `aid` int(11) NULL DEFAULT NULL COMMENT '文章id',
  `status` int(11) NULL DEFAULT NULL COMMENT '0-未审核\r\n1-通过\r\n2-垃圾',
  `reply` int(11) NULL DEFAULT NULL COMMENT '0-评论该文章\r\n其他数字-回复的评论id',
  `create_date` datetime(0) NULL DEFAULT NULL COMMENT '评论时间',
  `client` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '客户端信息',
  `avatar_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像链接',
  PRIMARY KEY (`cid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 109 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ciblog_comment
-- ----------------------------
INSERT INTO `ciblog_comment` VALUES (108, '127.0.0.1', 'ddddd', '测试员1', '1@qq.com', 1, 1, NULL, '2020-02-10 17:20:11', NULL, 'https://cube.elemecdn.com/9/c2/f0ee8a3c7c9638a54940382568c9dpng.png');

-- ----------------------------
-- Table structure for ciblog_meta
-- ----------------------------
DROP TABLE IF EXISTS `ciblog_meta`;
CREATE TABLE `ciblog_meta`  (
  `mid` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '分类或标签名称',
  `type` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'tag或者category\r\n',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  `count` int(11) NULL DEFAULT 0 COMMENT '使用该标签的文章数',
  `order` int(255) NULL DEFAULT NULL COMMENT '分类排序  tag为0',
  `parent` int(255) NULL DEFAULT NULL COMMENT '二级分类',
  PRIMARY KEY (`mid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 98 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ciblog_meta
-- ----------------------------
INSERT INTO `ciblog_meta` VALUES (71, 'vue', 'tag', NULL, 0, 0, 0);
INSERT INTO `ciblog_meta` VALUES (72, '日常', 'tag', NULL, 0, 0, 0);
INSERT INTO `ciblog_meta` VALUES (87, '日常瞎聊', 'category', '', 0, NULL, NULL);
INSERT INTO `ciblog_meta` VALUES (88, '测试分类', 'category', '', 0, NULL, NULL);
INSERT INTO `ciblog_meta` VALUES (89, '成功了', 'tag', NULL, 0, 0, 0);
INSERT INTO `ciblog_meta` VALUES (90, '6666', 'tag', NULL, 0, 0, 0);
INSERT INTO `ciblog_meta` VALUES (91, '加油加油', 'category', '测试\n', 0, NULL, NULL);

-- ----------------------------
-- Table structure for ciblog_settings
-- ----------------------------
DROP TABLE IF EXISTS `ciblog_settings`;
CREATE TABLE `ciblog_settings`  (
  `sid` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  PRIMARY KEY (`sid`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Fixed;

-- ----------------------------
-- Table structure for ciblog_user
-- ----------------------------
DROP TABLE IF EXISTS `ciblog_user`;
CREATE TABLE `ciblog_user`  (
  `uid` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id\r\n\r\n',
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户姓名',
  `password` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户密码',
  `mail` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户邮箱',
  `bilibili` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户哔哩哔哩（url地址）',
  `github` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户github（rul地址）',
  `nickname` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户昵称',
  `group_id` int(50) NULL DEFAULT NULL COMMENT '用户组',
  `imgurl` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像地址',
  `indexurl` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '主页地址',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ciblog_user
-- ----------------------------
INSERT INTO `ciblog_user` VALUES (1, 'admin', '111', '15204944127@163.com', 'https://space.bilibili.com/4568935', 'https://github.com/zhangyifei233', '猫不理的锅包肉', 0, 'https://xiaochengxuimg.oss-cn-beijing.aliyuncs.com/Blog/oh.jpg', 'http://localhost:8080/');

SET FOREIGN_KEY_CHECKS = 1;
